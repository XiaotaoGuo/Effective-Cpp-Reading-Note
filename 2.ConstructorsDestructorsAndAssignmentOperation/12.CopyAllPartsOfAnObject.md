# 条款12.复制对象时确保复制其一个成员

我们设计 class 时通常会将其内部成员变量封装起来，只用两个函数来进行对象的复制，即 copy 构造函数和 copy assignement 操作符 (即 `operator=`)，这里统称为 copy 函数。通过条款 5 我们可以知道，在我们没有显式定义 copy
函数时，编译器会自动为我们生成这些函数，其内部的定义是为被复制对象中的每一个成员变量进行一次复制。这在大部分情况下是没问题的，需要注意的是当我们自己定义 copy 函数时可能会遇到潜在的问题，如下例所示（完整代码见 ex1）：

```C++
class Customer {
public:
    Customer(const std::string& name_, const std::string& date_): name(name_), date(date_) {}
    Customer(const Customer& rhs);
    Customer& operator=(const Customer& rhs);

private:
    std::string name;
    std::string date;
};

Customer::Customer(const Customer& rhs): name(rhs.name) {
    std::cout << "Customer copy constructor called." << std::endl;
}

Customer& Customer::operator=(const Customer& rhs) {
    std::cout << "Customer copy assignment called." << std::endl;
    name = rhs.name;
    return *this;
```

上面这段代码中，不难发现我们漏复制了 `Customer` 类中的 `date` 成员变量，因此我们的复制操作只是局部复制，而编译器即使在警告级别最高的情况下也不会因此抛出错误（因为没有语法错误）。当然在这种情况下我们只需要简单地将其补上即可，但是这意味着我们每添加一个成员变量，都必须记得在 copy 函数中手动添加对应成员变量的
copy，如果忘记了我们可能也不会发现（直到遇到问题调试的时候）。
