# 条款 05：了解 C++ 静默编写和调用的函数

## 引子

想象一下我们写了如下空类：

```C++
class Empty{};
```

看似这个类里没有任何成员变量和方法，但是通过编译器编译之后，会自动地为我们的类添加一些函数，添加了函数之后的类和以下类等效：

```C++
class Empty {
public:
    // default 构造函数
    Empty() {}
    // copy 构造函数
    Empty(const Empty& rhs) {}
    // 析构函数
    ~Empty() {}
    // copy assignment 操作符
    Empty& operator=(const Empty& rhs) {}
};
```

但是要注意到这些函数的定义并不是无条件生成的，只有当程序有出现过该类函数被调用的时候才会生成相应的函数体定义（参考 [cpprefernce:Default constructors](https://en.cppreference.com/w/cpp/language/default_constructor)），如下所示：

```C++
class Empty {};

Empty e1; // default 构造函数被生成，同时析构函数也生成
Empty e2(e1) // copy 构造函数生成
e2 = e1 // copy assignment 操作符生成
```

下面我们来讨论一下这四类函数的具体情况，详细介绍 copy 构造函数和 copy assignment 操作符。

## default 构造函数和析构函数

default 构造函数和析构函数的作用主要是：调用该类 base class 和 non-static 成员变量的构造函数和析构函数。这里注意两点：

* 由于 default 构造函数只会执行 non-static 成员变量的构造函数，所以对基本类型的成员变量并不会自发地进行初始化，如同 条款04 所说，如果我们的类有基本类型成员变量，我们应该手动创建构造函数通过初始化列表对其进行初始化；
* 编译器自动生成的析构函数是 non-virtual 的，除非该类的 base class 自身声明有 virtual 析构函数。

## copy 构造函数和 copy assignment 操作符

考虑以下模板类：

```C++
template<typename T>
class NamedObject {
public:
    NamedObject(const char* name, const T& value);
    NamedObject(cconst std::string& name, const T& value);
    ...
private:
    std::string nameValue;
    T objectValue;
};
```

由于该类已经声明了构造函数，所以编译器不会再自动生成 default 构造函数。因此在这种情况下，我们声明了一个要求传入参数的构造函数之后就无须担心编译器会自动生成一个不需要传入参数的构造函数。而由于类中没有声明 copy 构造函数和 copy assignment 操作符，所以编译器会为它创建这两个函数。

### copy 构造函数

构造函数的用法如下：

```C++
NamedObject<int> no1("Smallest Prime Number", 2);   // 调用用户定义的构造函数
NamedObject<int> no2(no1);                          // 调用 copy 构造函数
```

编译器生成的 copy 构造函数以传入类中的每一个成员变量，对自身所有成员变量进行构造或者拷贝。#TODO

### copy assignment 操作符

## 结论